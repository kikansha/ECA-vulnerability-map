#title: "ECA Dashboard - February 2024"
#author: "Thomas Mahony"

#This script creates a dashboard for the climate vulnerability and resilience data, displaying it in an interactive map format and allowing users to construct their own vulnerability and resilience indices.

Sys.setenv(LC_MESSAGES = "en_US.UTF-8") # sets language to English
options(scipen=999) # disables scientific notation
library(here) # navigating relative filepaths
library(openxlsx) # for handling Excel files
library(sf) # for handling geospatial data
library(shiny) # for visualization
library(shinyWidgets) # for more UI options
library(leaflet) # for maps
library(htmltools)
library(dplyr)
library(openxlsx) # For handling Excel files

#Load shapefiles:

eca_admin0_rotated <- st_read(here("Shapes", "eca_admin0_rotated_simplified.shp")) 
eca_admin1_rotated <- st_read(here("Shapes", "eca_admin1_rotated_simplified.shp")) 
eca_admin2_rotated <- st_read(here("Shapes", "eca_admin2_rotated_simplified.shp")) 

#Load and merge data:

load(here("Data", "cisi_adm1_data.RData"))
load(here("Data", "cisi_adm2_data.RData"))

adm1_mergedData <- left_join(eca_admin1_rotated, adm1_data, by = c("ADM1_CODE", "ADM1_NAME", "ADM0_CODE", "ADM0_NAME")) %>%
  select(-ISO3, -ISO3166_10, -STR1_YEAR, -EXP1_YEAR, -DISP_AREA, -Shape_Leng, -Shape_Len0, -STATUS)

adm2_mergedData <- left_join(eca_admin2_rotated, adm2_data, by = c("ADM2_CODE", "ADM2_NAME", "ADM1_CODE", "ADM1_NAME", "ADM0_CODE", "ADM0_NAME")) %>%
  select(-ISO3, -ISO3166_10, -STR2_YEAR, -EXP2_YEAR, -DISP_AREA, -Shape_Leng, -Shape_Len0, -STATUS)

# Remove rows with NA population
adm1_mergedData <- adm1_mergedData[!is.na(adm1_mergedData$population), ]
adm2_mergedData <- adm2_mergedData[!is.na(adm2_mergedData$population), ]

#Helper functions:

# Define the color palette
colorPalette <- colorNumeric(
  palette = c("green", "gray90", "red"),
  domain = c(-1, 1),
  na.color = "transparent"
)

# Function to calculate robust z-scores
calculateZScore <- function(x) {
  x_mean <- mean(x, na.rm = TRUE)
  x_sd <- sd(x, na.rm = TRUE)
  
  if (x_sd == 0) {
    z_scores <- rep(0, length(x))  # Return zeros if standard deviation is zero
  } else {
    z_scores <- (x - x_mean) / x_sd
  }
  
  return(z_scores)
}

# Function to apply log transformation
logTransform <- function(data) {
  return(log1p(data))
}

# Function to normalize data
normalizeData <- function(data) {
  min_val <- min(data, na.rm = TRUE)
  max_val <- max(data, na.rm = TRUE)
  
  if (max_val == min_val) {
    return(rep(0, length(data)))  # Return zeros if all values are the same
  } else {
    return((data - min_val) / (max_val - min_val))
  }
}

# Function to calculate combined normalized z-scores
calculateCombinedScore <- function(data, selected_indicators, weights) {
  selected_data <- data[, selected_indicators, drop = FALSE]
  
  # Apply log transformation to reduce skewness
  log_transformed_data <- apply(selected_data, 2, logTransform)
  
  # Calculate z-scores for each selected indicator
  z_scores_data <- apply(log_transformed_data, 2, calculateZScore)
  
  # Normalize each z-score
  normalized_z_scores_data <- apply(z_scores_data, 2, normalizeData)
  
  # Check that the length of weights matches the number of columns
  if (length(weights) != ncol(normalized_z_scores_data)) {
    stop("Length of weights must match the number of selected indicators")
  }
  
  # Apply weights to each value in normalized_z_scores_data
  weighted_normalized_z_scores_data <- sweep(normalized_z_scores_data, 2, weights, `*`)
  
  # Calculate the weighted sum across the columns
  weighted_sum <- rowSums(weighted_normalized_z_scores_data, na.rm = TRUE)
  
  # Calculate z-scores of the weighted sum
  summed_z_scores <- calculateZScore(weighted_sum)
  
  # Normalize the final z-scores
  normalized_final_z_scores <- normalizeData(summed_z_scores)
  
  return(normalized_final_z_scores)
}

# Function to normalize weights
normalizeWeights <- function(weights) {
  total <- sum(weights)
  if (total == 0) {
    return(rep(0, length(weights)))  # Return zero weights if the sum is zero
  } else {
    return(weights / total)  # Normalize weights
  }
}

# Helper function to shift the median using logit transformation
shift_median_logit <- function(column, desired_median = 0.5) {
  logit <- function(p) {
    if (p <= 0 || p >= 1) stop("Values must be between 0 and 1 for logit transformation")
    log(p / (1 - p))
  }
  inverse_logit <- function(x) exp(x) / (1 + exp(x))
  
  # Replace NA values with zeros
  column[is.na(column)] <- 0
  
  # Normalize the data to be within the (0, 1) range
  min_val <- min(column)
  max_val <- max(column)
  
  # If min and max are equal, return the original column (no variance case)
  if (min_val == max_val) {
    return(rep(0.5, length(column)))  # Return 0.5 (or another constant within 0-1) if all values are the same
  }
  
  normalized_column <- (column - min_val) / (max_val - min_val)
  
  # Ensure values are strictly within (0, 1) by clamping
  epsilon <- .Machine$double.eps
  normalized_column <- pmin(pmax(normalized_column, epsilon), 1 - epsilon)
  
  # Logit transformation
  logit_data <- sapply(normalized_column, logit)
  
  # Shift the data
  shifted_logit_data <- logit_data + (logit(desired_median) - median(logit_data))
  
  # Transform back
  shifted_data <- inverse_logit(shifted_logit_data)
  
  # Ensure the data is within the 0-1 range
  shifted_data <- pmin(pmax(shifted_data, 0), 1)
  
  # Rescale the data back to the original range
  rescaled_data <- shifted_data * (max_val - min_val) + min_val
  
  return(rescaled_data)
}

# Function to create labels based on administrative level
createLabels <- function(data, adminLevel) {
  if (adminLevel == "adm1") {
    sprintf("%s<br>
            <strong>%s</strong><br>
            Risk Score: %.2f<br>
            Resilience Score: %.2f<br>
            Resilience Adjusted Risk: %.2f",
            data$ADM0_NAME,
            data$ADM1_NAME,
            unlist(data$combined_risk_zscore),
            unlist(data$combined_mitigating_zscore),
            unlist(data$resilience_adjusted_hazard))
  } else {
    sprintf("%s<br>
            <strong>%s</strong><br>
            %s<br>
            Risk Score: %.2f<br>
            Resilience Score: %.2f<br>
            Resilience Adjusted Risk: %.2f",
            data$ADM0_NAME,
            data$ADM2_NAME,
            data$ADM1_NAME,
            unlist(data$combined_risk_zscore),
            unlist(data$combined_mitigating_zscore),
            unlist(data$resilience_adjusted_hazard))
  }
}

# Function to export data to Excel
exportToExcel <- function(data, filepath, adminLevel) {
  
  # Define the correct column names
  cols_to_export <- c(
    if (adminLevel == "adm1") {
      c("ADM1_CODE", "ADM1_NAME", "ADM0_CODE", "ADM0_NAME")
    } else {
      c("ADM2_CODE", "ADM2_NAME", "ADM1_CODE", "ADM1_NAME", "ADM0_CODE", "ADM0_NAME")
    },
    "population", "area", "pop_density",
    "normalized_temp_var", 
    "normalized_earthquake_risk", "flood_freq_normalized", "drought_risk_normalized",
    "heat_risk_normalized", "landslide_risk_normalized", "pollution_normalized",
    "energy_normalized", "water_normalized", "waste_normalized",
    "transportation_normalized", "telecommunications_normalized", "education_normalized",
    "health_normalized", "combined_risk_zscore", "combined_mitigating_zscore", 
    "resilience_adjusted_hazard"
  )
  
  # Ensure the columns to export exist in the data frame
  missing_cols <- setdiff(cols_to_export, names(data))
  if (length(missing_cols) > 0) {
    stop(paste("The following columns are missing:", paste(missing_cols, collapse = ", ")))
  }
  
  data_to_export <- data[, cols_to_export, drop = FALSE] %>%
    st_drop_geometry()
  
  # Create and save the workbook
  wb <- createWorkbook()
  addWorksheet(wb, "Data")
  writeDataTable(wb, "Data", data_to_export, startRow = 1, startCol = 1, tableStyle = "TableStyleMedium2")
  saveWorkbook(wb, filepath, overwrite = TRUE)
}

#Preprocess data:

# Specify the columns for z-score calculation
original_cols <- c(
  "temp_var",
  "earthquake_risk",
  "flood_freq",
  "drought_risk",
  "heat_risk",
  "landslide_risk",
  "pollution",
  "energy",
  "water",
  "waste",
  "transportation",
  "telecommunications",
  "education",
  "health"
)

# Normalize and calculate z-scores for specified columns in adm1_mergedData
for (col in original_cols) {
  if (col %in% names(adm1_mergedData) && is.numeric(adm1_mergedData[[col]])) {
    # Normalize the data
    adm1_mergedData[[paste0(col, "_normalized")]] <- normalizeData(adm1_mergedData[[col]])
    # Calculate z-scores
    adm1_mergedData[[paste0(col, "_zscore")]] <- calculateZScore(adm1_mergedData[[paste0(col, "_normalized")]])
  }
}

# Normalize and calculate z-scores for specified columns in adm2_mergedData
for (col in original_cols) {
  if (col %in% names(adm2_mergedData) && is.numeric(adm2_mergedData[[col]])) {
    # Normalize the data
    adm2_mergedData[[paste0(col, "_normalized")]] <- normalizeData(adm2_mergedData[[col]])
    # Calculate z-scores
    adm2_mergedData[[paste0(col, "_zscore")]] <- calculateZScore(adm2_mergedData[[paste0(col, "_normalized")]])
  }
}

#Create Shiny UI:

ui <- fluidPage(
  tags$head(
    tags$style(HTML("
      body {
        background-color: #f0f0f0;
        font-family: Arial, sans-serif;
      }
      
      .slider-label {
        display: flex;
        align-items: center;
      }
      
      .slider-label span {
        margin-left: 5px;
        color: #888;
        font-size: 16px;
      }
    "))
  ),
  absolutePanel(
    id = "controls",
    top = 10, left = 10, right = "auto", bottom = "auto",
    width = 250, height = "auto",
    style = "z-index:400; background-color: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px;",
    h4("Map Controls"),
    checkboxInput("toggleMap", "Show Base Map", FALSE),
    radioButtons("adminLevel", "Administrative Level:",
                 choices = list("Admin Level 1" = "adm1",
                                "Admin Level 2" = "adm2"),
                 selected = "adm1"),
    actionButton("reset", "Reset Map View"),
    br(), br(),
    sliderInput("riskWeight", tags$div(class = "slider-label", "Risk Weight", tags$span("\u24D8", title = "Adjusts contribution of risk variables to overal score.")), min = 0, max = 1, value = 1, step = 0.1, ticks = FALSE),
    sliderInput("resilienceWeight", tags$div(class = "slider-label", "Resilience Weight", tags$span("\u24D8", title = "Adjusts contribution of mitigating variables to overall score.")), min = 0, max = 1, value = 1, step = 0.1, ticks = FALSE),
    downloadButton("export_data", "Export to Excel")
  ),
  absolutePanel(
    top = "auto", left = 10, right = "auto", bottom = 10,
    width = "auto", height = "auto",
    style = "z-index:400; background-color: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px;",
    h4("Risk Indicators"),
    actionButton("allRisk100", "All 100%"),
    actionButton("allRisk0", "All 0%"),
    br(),
    lapply(c(
      "normalized_temp_var",
      "normalized_earthquake_risk",
      "flood_freq_normalized",
      "drought_risk_normalized",
      "heat_risk_normalized",
      "landslide_risk_normalized",
      "pollution_normalized"
    ), function(x) sliderInput(inputId = paste0(x, "_slider"), label = tags$div(class = "slider-label", switch(x,
                                                                                                               "normalized_temp_var" = "Temperature Variability",
                                                                                                               "normalized_earthquake_risk" = "Earthquake Risk",
                                                                                                               "flood_freq_normalized" = "Flood Frequency",
                                                                                                               "drought_risk_normalized" = "Drought Risk",
                                                                                                               "heat_risk_normalized" = "Heat Risk",
                                                                                                               "landslide_risk_normalized" = "Landslide Risk",
                                                                                                               "pollution_normalized" = "Pollution"
    ), tags$span("\u24D8", title = switch(x,
                                          "normalized_temp_var" = "Average variation in surface temperature by month across all months, 2000-2023, NASA GLDAS",
                                          "normalized_precip_var" = "Average variation in precipitation by month across all months, 2000-2023, NASA GLDAS",
                                          "normalized_crop_perc_2020" = "Land Cover CCI, 2020, European Space Agency",
                                          "normalized_earthquake_risk" = "Global Earthquake Hazard Distribution, 1976-2002, NASA SEDAC",
                                          "flood_freq_normalized" = "Number of flood incidents, 1985-2022, Dartmouth Flood Observatory",
                                          "drought_risk_normalized" = "Frequency of severe drought when more than 30% of cropland is affected, 1984-2022, FAO",
                                          "heat_risk_normalized" = "Extreme heat hazard based on daily maximum WBGT, 100 year return period, GFDRR",
                                          "landslide_risk_normalized" = "Average annual frequency of significant landslides, 1980-2018, World Bank-Arup",
                                          "pollution_normalized" = "Annual average levels of PM2.5, 2019, NASA SEDAC"
    ))), min = 0, max = 1, value = 1, step = 0.1, ticks = FALSE))
  ),
  absolutePanel(
    top = "auto", left = "auto", right = 10, bottom = 10,
    width = "auto", height = "auto",
    style = "z-index:400; background-color: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 5px;",
    h4("Mitigating Factors"),
    actionButton("allResilience100", "All 100%"),
    actionButton("allResilience0", "All 0%"),
    br(),
    lapply(c(
      "energy_normalized",
      "water_normalized",
      "waste_normalized",
      "transportation_normalized",
      "telecommunications_normalized",
      "education_normalized",
      "health_normalized"
    ), function(x) sliderInput(inputId = paste0(x, "_slider"), label = tags$div(class = "slider-label", switch(x,
                                                                                                               "energy_normalized" = "Energy Access",
                                                                                                               "water_normalized" = "Water Access",
                                                                                                               "waste_normalized" = "Waste Management",
                                                                                                               "transportation_normalized" = "Transportation",
                                                                                                               "telecommunications_normalized" = "Telecommunications",
                                                                                                               "education_normalized" = "Education",
                                                                                                               "health_normalized" = "Health"
    ), tags$span("\u24D8", title = switch(x,
                                          "energy_normalized" = "Energy infrastructure aggregate score, 2022, Critical Infrastructure Spatial Index (CISI)",
                                          "water_normalized" = "Water infrastructure aggregate score, 2022, Critical Infrastructure Spatial Index (CISI)",
                                          "waste_normalized" = "Waste management infrastructure aggregate score, 2022, Critical Infrastructure Spatial Index (CISI)",
                                          "transportation_normalized" = "Transportation infrastructure aggregate score, 2022, Critical Infrastructure Spatial Index (CISI)",
                                          "telecommunications_normalized" = "Telecommunications infrastructure aggregate score, 2022, Critical Infrastructure Spatial Index (CISI)",
                                          "education_normalized" = "Education infrastructure aggregate score, 2022, Critical Infrastructure Spatial Index (CISI)",
                                          "health_normalized" = "Health infrastructure aggregate score, 2022, Critical Infrastructure Spatial Index (CISI)"
    ))), min = 0, max = 1, value = 1, step = 0.1, ticks = FALSE))
  ),
  leafletOutput("map", width = "100%", height = "100vh")
)

#Create Shiny server:

server <- function(input, output, session) {
  # Initialize the Leaflet map without the base map layer
  output$map <- renderLeaflet({
    leaflet(options = leafletOptions(zoomControl = FALSE)) %>%
      setView(lat = 60, lng = -300, zoom = 4) %>%
      addPolylines(data = eca_admin0_rotated, color = "#000000", weight = 2)
  })
  
  observeEvent(input$allRisk100, {
    risk_sliders <- c(
      "normalized_temp_var",
      "normalized_earthquake_risk",
      "flood_freq_normalized",
      "drought_risk_normalized",
      "heat_risk_normalized",
      "landslide_risk_normalized",
      "pollution_normalized"
    )
    
    lapply(risk_sliders, function(slider) {
      updateSliderInput(session, paste0(slider, "_slider"), value = 1)
    })
  })
  
  observeEvent(input$allRisk0, {
    risk_sliders <- c(
      "normalized_temp_var",
      "normalized_earthquake_risk",
      "flood_freq_normalized",
      "drought_risk_normalized",
      "heat_risk_normalized",
      "landslide_risk_normalized",
      "pollution_normalized"
    )
    
    lapply(risk_sliders, function(slider) {
      updateSliderInput(session, paste0(slider, "_slider"), value = 0)
    })
  })
  
  observeEvent(input$allResilience100, {
    resilience_sliders <- c(
      "energy_normalized",
      "water_normalized",
      "waste_normalized",
      "transportation_normalized",
      "telecommunications_normalized",
      "education_normalized",
      "health_normalized"
    )
    
    lapply(resilience_sliders, function(slider) {
      updateSliderInput(session, paste0(slider, "_slider"), value = 1)
    })
  })
  
  observeEvent(input$allResilience0, {
    resilience_sliders <- c(
      "energy_normalized",
      "water_normalized",
      "waste_normalized",
      "transportation_normalized",
      "telecommunications_normalized",
      "education_normalized",
      "health_normalized"
    )
    
    lapply(resilience_sliders, function(slider) {
      updateSliderInput(session, paste0(slider, "_slider"), value = 0)
    })
  })
  
  # Reactive expression for fetching data based on admin level selection
  reactiveSelectedData <- reactive({
    req(input$adminLevel)
    
    data <- if (input$adminLevel == "adm1") {
      adm1_mergedData
    } else {
      adm2_mergedData
    }
    
    data_no_geometry <- st_drop_geometry(data)
    
    selected_risk_indicators <- c(
      "normalized_temp_var",
      "normalized_earthquake_risk",
      "flood_freq_normalized",
      "drought_risk_normalized",
      "heat_risk_normalized",
      "landslide_risk_normalized",
      "pollution_normalized"
    )
    
    selected_mitigating_factors <- c(
      "energy_normalized",
      "water_normalized",
      "waste_normalized",
      "transportation_normalized",
      "telecommunications_normalized",
      "education_normalized",
      "health_normalized"
    )
    
    risk_indicator_weights <- sapply(selected_risk_indicators, function(x) input[[paste0(x, "_slider")]])
    mitigating_factor_weights <- sapply(selected_mitigating_factors, function(x) input[[paste0(x, "_slider")]])
    
    risk_indicator_weights <- normalizeWeights(risk_indicator_weights)
    mitigating_factor_weights <- normalizeWeights(mitigating_factor_weights)
    
    data_no_geometry[selected_mitigating_factors] <- data.frame(lapply(data_no_geometry[selected_mitigating_factors], shift_median_logit))
    
    data_no_geometry$combined_risk_zscore <- calculateCombinedScore(data_no_geometry, selected_risk_indicators, risk_indicator_weights)
    data_no_geometry$combined_mitigating_zscore <- calculateCombinedScore(data_no_geometry, selected_mitigating_factors, mitigating_factor_weights)
    
    data_no_geometry$combined_risk_zscore <- normalizeData(data_no_geometry$combined_risk_zscore)
    data_no_geometry$combined_mitigating_zscore <- normalizeData(data_no_geometry$combined_mitigating_zscore)
    
    data_no_geometry$combined_risk_zscore <- data_no_geometry$combined_risk_zscore * input$riskWeight
    data_no_geometry$combined_mitigating_zscore <- data_no_geometry$combined_mitigating_zscore * input$resilienceWeight
    
    data_no_geometry$resilience_adjusted_hazard <- data_no_geometry$combined_risk_zscore - data_no_geometry$combined_mitigating_zscore
    
    data_no_geometry$fillColor <- colorPalette(data_no_geometry$resilience_adjusted_hazard)
    
    data <- st_as_sf(data_no_geometry, geometry = st_geometry(data))
    
    data
  })
  
  # Observer to update polygons without resetting view
  observe({
    data <- reactiveSelectedData()
    labels <- createLabels(data, input$adminLevel)
    labels <- lapply(labels, htmltools::HTML)
    
    leafletProxy("map", data = data) %>%
      clearShapes() %>%
      addPolygons(
        fillColor = ~fillColor, 
        color = "blue",
        fillOpacity = 0.7,
        weight = 0.2,
        layerId = ~if (input$adminLevel == "adm1") ADM1_CODE else ADM2_CODE,
        label = labels,
        labelOptions = labelOptions(
          direction = "auto",
          style = list("font-size" = "12px")
        )
      ) %>%
      addPolylines(data = eca_admin0_rotated, color = "#000000", weight = 2)  # Re-add borders
  })
  
  # Observer for toggling base map visibility
  observeEvent(input$toggleMap, {
    proxy <- leafletProxy("map")
    if (input$toggleMap) {
      proxy %>%
        addTiles(group = "Base Map")
    } else {
      proxy %>%
        clearGroup("Base Map")
    }
  })
  
  # Observer to reset map view
  observeEvent(input$reset, {
    leafletProxy("map", session) %>%
      setView(lat = 60, lng = -270, zoom = 3)
  })
  
  # Export data to Excel
  output$export_data <- downloadHandler(
    filename = function() {
      paste0("Data-Export-", Sys.Date(), ".xlsx")
    },
    content = function(file) {
      data <- reactiveSelectedData()
      adminLevel <- input$adminLevel
      exportToExcel(data, file, adminLevel)
    }
  )
}

#Run the app:

shinyApp(ui = ui, server = server)


